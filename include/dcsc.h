/*
DOUBLY COMPRESSED SPARSE ROWS HEADER FILE
*/

double randNum() {/* initialize random seed: */
	std::random_device rd;  //Will be used to obtain a seed for the random number engine
	std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
	std::uniform_real_distribution<> dis(0, 9);
	//Use dis to transform the random unsigned int generated by gen into a double in [0,1]
	//Each call to dis(gen) generates a new random double
	auto randx = dis(gen);        //get random x0
	//      std::cout << "Random X " << randx << std::endl;
	return randx;
}

void printVec (const std::vector<auto> vec) {
	for (auto i : vec){	//pythonic range-based for loops
		std::cout << i << "\t";
	}
	std::cout << std::endl;
}

void printMatrix (const auto lead_dim, const auto lag_dim, const auto msg, const auto matrix);

void print_tuples (auto vector_of_tuples);

void random_denseMat(const auto lead_dim, const auto lag_dim, auto &mat_A){
	for (int i = 0, ii = 0; i != lag_dim; ++i) {
		for (int j = 0; j != lead_dim; ++j, ++ii) {
			auto tmpA = rand()%10;
			mat_A[ii] = tmpA;
		}
	}
}


void diagonalMatrix(const auto lead_dim, const auto lag_dim, auto &mat_A){
	for (int i = 0, ii=0; i != lag_dim; ++i) {
		for (int j = 0; j != lead_dim; ++j, ++ii) {
			if(i==j){
				auto tmpA = randNum();
				mat_A[ii] = tmpA;			//row-major
			}
			else
				mat_A[ii] = 0;
		}
	}
}

void transpose(const auto lead_dim, const auto lag_dim, const std::vector<auto> matrix, std::vector<auto> &transpose_matrix) {
	//this simply changes data layout	
	for (int i = 0, ii = 0; i != lag_dim; ++i) {
		for (int j = 0;  j != lead_dim; ++j, ++ii) {
			transpose_matrix[j*lead_dim + i] = matrix[ii];
		}
	}
}
void get_dim_from_major (const auto lead_dim, const auto lag_dim, auto &rows, auto &cols);
void check_major (const auto m, const auto n, auto &leading_dim, auto &lagging_dim);
void convert_triples_to_dcsc(const int rows, const int cols, const auto triples_A, auto &val, auto &indices, auto &cp_dcsc, auto &jc_dcsc, auto &aux, auto &nnz, auto &nzc, auto &upper_bound_cf); 

void get_sorted_indices(const auto lead_dim, const auto lag_dim, const auto sparse_matrix, auto &val, auto &indices);

void access_elem_in_matrix(const auto &i, const auto &j, const auto nnz, const auto nzc, const auto cf, const auto &val, const auto &ir, const auto &jc, const auto &cp, const auto &aux, const auto &rows, const auto &cols);