/*
DOUBLY COMPRESSED SPARSE ROWS
*/

#include <iostream>
#include <vector>
#include <string>
#include <random>
#include <new>
#include <cblas.h>
#include <algorithm>				//Checking if v contains the element x

double randNum() {/* initialize random seed: */
	std::random_device rd;  //Will be used to obtain a seed for the random number engine
	std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
	std::uniform_real_distribution<> dis(0, 9);
//Use dis to transform the random unsigned int generated by gen into a double in [0,1]
//Each call to dis(gen) generates a new random double
	auto randx = dis(gen);        //get random x0
//      std::cout << "Random X " << randx << std::endl;
	return randx;
}

void print_ip_mat (auto lead_dim, auto lag_dim, auto msg, const auto mat){
	std::cout << msg << std::endl;
	int cnt = 0;
	for (int i = 0; i != lag_dim*lead_dim; ++i){
		std::cout << mat[i] << "\t";
		cnt++;
		if(cnt == lead_dim){					//row major: change to cols if col-major
			std::cout << std::endl;
			cnt = 0;
		}
	}
}

void printVec (const std::vector<auto> vec) {
	for (int i = 0; i < vec.size(); i++){
		std::cout << vec[i] << "\t";
	}
	std::cout << std::endl;
}

void printMatrix (const int lead_dim, const int lag_dim, const std::vector<auto> vec) {
	for (int i = 0, ii=0; i != lag_dim; ++i) {
		for (int j = 0; j != lead_dim; ++j, ++ii) {
			std::cout << vec[ii] << "\t";
		} std::cout << std::endl;
	}
}

void random_denseMat(const auto lead_dim, const auto lag_dim, auto &mat_A){
	for (int i = 0, ii = 0; i != lag_dim; ++i) {
		for (int j = 0; j != lead_dim; ++j, ++ii) {
			auto tmpA = rand()%10;
			mat_A[ii] = tmpA;
		}
	}

}

void diagonalMatrix(const auto lead_dim, const auto lag_dim, auto &mat_A){
	for (int i = 0, ii=0; i != lag_dim; ++i) {
		for (int j = 0; j != lead_dim; ++j, ++ii) {
			if(i==j){
				auto tmpA = randNum();
				mat_A[ii] = tmpA;			//row-major
			}
			else
				mat_A[ii] = 0;
		}
	}

}
void transpose(const auto lead_dim, const auto lag_dim, const std::vector<auto> matrix, std::vector<auto> &transpose_matrix) {
	for (int i = 0, ii = 0; i != lag_dim; ++i) {
		for (int j = 0;  j != lead_dim; ++j, ++ii) {
			transpose_matrix[j*lead_dim + i] = matrix[ii];
		}
	}
}

void get_sorted_indices(const auto lead_dim, const auto lag_dim, const std::vector <auto> sparse_matrix, std::vector <auto> &val, std::vector <auto> &col_idx, std::vector <auto> &row_idx) {						//pass in vector
	std::vector <int> row_ptr;
	int cnt = 0;
	bool new_row = false;
	for(int i = 0, ii=0; i != lag_dim; ++i){
		for(int j = 0; j != lead_dim; ++j, ++ii){
			if (j==0) 
				new_row = true;
			if(sparse_matrix[ii] != 0){
				val.push_back(sparse_matrix[ii]);
				if(std::find(row_idx.begin(), row_idx.end(), i) == row_idx.end()) {		//Return value of std::find Iterator to the first element satisfying the condition or last if no such element is found.
	    			//vector row_ind doesnt contain index i
					row_idx.push_back(i);
				} 
				if(std::find(col_idx.begin(), col_idx.end(), j) == col_idx.end()) {		//Return value of std::find Iterator to the first element satisfying the condition or last if no such element is found.
    				//vector col_ind doesnt contain item j
					col_idx.push_back(j);
				}
				if (new_row == true) {
					row_ptr.push_back(cnt);
					new_row = false;
				}
				cnt++;
			}
		} 
	}

//	std::cout << "val" << std::endl;
//	printVec(val);
	std::sort(col_idx.begin(), col_idx.end());						//get sorted vector of indices in order to get sorted lists after intersection
	std::sort(row_idx.begin(), row_idx.end());

/*	std::cout << "column index" << std::endl;
	printVec(col_ind);
	std::cout << "row index" << std::endl;
	printVec(row_ind);
	std::cout << "row ptr in csr storage" << std::endl;
	printVec(row_ptr);
*/
}

void isect (const std::vector<auto> idx_A, const std::vector<auto> idx_B, std::vector<auto> &isect_vec) {			//intersection of A.JC and BT.JC; set of indices that contribute non-trivially to outer product
	for (int i = 0; i!= idx_A.size(); ++i){
		for (int j = 0; j!= idx_B.size(); ++j){
			if(idx_A[i] == idx_B[j])							//get ONLY elements common only once
				isect_vec.push_back(idx_A[i]);
		}
	}	
}

int main (int argc, char *argv[]) {
	//int m = atoi(argv[1]);
	//int n = atoi(argv[1]);
	int m, n;
	m = n = 4;
	
	int lead_dim, lag_dim;					//SET LEADING DIMENSION
	std::string leading = argv[1];
	std::cout << leading << std::endl;
	if (leading == "row-major" || leading == "rowmajor"){
		lead_dim = n;						//row-major => leading_dim = #cols
		lag_dim = m;
	}
	else if (leading == "col-major"|| leading == "colmajor") {
		lead_dim = m;						//col-major => leading_dim = #rows
		lag_dim = n;	
	}
	/*
	Generate random sparse matrix
	
	int length = m*n;
	std::vector<double> sp(length);
	double array [length];
	
	int t = 6;											//target nnz elements
	for (int i = 0; i < t; ++i) {
		int index = (int) (length * (int) randNum());
		array[index] = i % 2 ? -1 : 1;
	}
	//print_ip_mat (m, n, "sparse_matrix", array);
	//end sparse
	*/

	std::vector<double> sparse = {1, 2, 0, 0, 0, 0, 0, 0, 2, 3, 4, 0, 3, 0, 5, 16};
	//print_ip_mat(m, n, "sparse matrix manual", sparse);
	
	std::vector<double> A = sparse;

	std::vector <double> val_A;
	std::vector <int> col_idx_A, row_idx_A;
	get_sorted_indices(lead_dim, lag_dim, A, val_A, col_idx_A, row_idx_A);				//get col indices of A									//matrix stored in row major
	std::cout << "A matrix" << std::endl;
	printMatrix(lead_dim, lag_dim, A);
	std::cout << "A col idx" << std::endl;
	printVec(col_idx_A);
	std::cout << "A row idx" << std::endl;
	printVec(row_idx_A);

	std::vector<double> B = sparse;
	std::cout << "B matrix" << std::endl;
	printMatrix(lead_dim, lag_dim, B);
	std::vector<double> Btrans (B.size());
	transpose(lead_dim, lag_dim, B, Btrans);
	std::cout << "B transpose matrix" << std::endl;
	printMatrix(lead_dim, lag_dim, Btrans);			//print transposed matrix

	std::vector <double> val_B;
	std::vector <int> col_idx_B, row_idx_B;
	get_sorted_indices(lead_dim, lag_dim, Btrans, val_B, col_idx_B, row_idx_B);			//swap lead and lag_dim of B to input transpose of B
	std::cout << "BT col idx" << std::endl;
	printVec(col_idx_B);
	std::cout << "BT row idx" << std::endl;
	printVec(row_idx_B);

	std::vector<double> isect_cols, isect_rows;
	isect(col_idx_A, col_idx_B, isect_cols);
	isect(row_idx_A, row_idx_B, isect_rows);
	std::cout << "set of col indices common to A and BT" << std::endl;
	printVec(isect_cols);
	std::cout << "set of row indices common to A and BT" << std::endl;
	printVec(isect_rows);

	return 0;
}