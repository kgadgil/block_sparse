/*
DOUBLY COMPRESSED SPARSE ROWS
*/

#include <iostream>
#include <vector>
#include <string>
#include <random>
#include <new>
#include <tuple>
#include <cblas.h>
#include <algorithm>				//Checking if v contains the element x
#include <iterator>

std::string which_major;
int leading_dim, laggging_dim;
typedef std::vector<std::tuple<int, int, double>> my_tuple;

double randNum() {/* initialize random seed: */
	std::random_device rd;  //Will be used to obtain a seed for the random number engine
	std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
	std::uniform_real_distribution<> dis(0, 9);
	//Use dis to transform the random unsigned int generated by gen into a double in [0,1]
	//Each call to dis(gen) generates a new random double
	auto randx = dis(gen);        //get random x0
	//      std::cout << "Random X " << randx << std::endl;
	return randx;
}

void get_dim_from_major (const auto lead_dim, const auto lag_dim, auto &rows, auto &cols) {
	if (which_major == "row-major" || which_major == "rowmajor") {
		rows = lag_dim;
		cols = lead_dim;
	}
	else if (which_major == "col-major" || which_major == "colmajor") {
		rows = lead_dim;
		cols = lag_dim;
	}
	else {
		std::cout << "which major? you suck" << std::endl;
	}
}

void printVec (const std::vector<auto> vec) {
	for (auto i : vec){	//pythonic range-based for loops
		std::cout << i << "\t";
	}
	std::cout << std::endl;
}

void printMatrix (const auto lead_dim, const auto lag_dim, const auto msg, const auto matrix) {
	std::cout << msg << std::endl;
	int rows, cols;
	get_dim_from_major(lead_dim, lag_dim, rows, cols);
	//std::cout << "rows " << rows << std::endl;
	//std::cout << "cols " << cols << std::endl;
	for (int i = 0; i != rows; ++i) {
		for (int j = 0; j != cols; ++j) {
			if (which_major == "row-major" || which_major == "rowmajor") {
				std::cout << matrix[i*rows + j] << "\t";
			}
			else if (which_major == "col-major" || which_major == "colmajor") {
				std::cout << matrix[j*rows + i] << "\t";
			}
		} std::cout << std::endl;
	}
}

void print_tuples (auto vector_of_tuples) {
	//print tuples
	for (my_tuple::const_iterator i = vector_of_tuples.begin(); i != vector_of_tuples.end(); ++i) {
		std::cout << std::get<0> (*i) << "\t ";
		std::cout << std::get<1> (*i) << "\t ";
		std::cout << std::get<2> (*i) << std::endl;
	}
}

void check_major (const auto m, const auto n, auto &leading_dim, auto &lagging_dim) {
	std::cout << which_major << std::endl;
	if (which_major == "row-major" || which_major == "rowmajor"){
		leading_dim = n;						//row-major => leading_dim = #cols
		lagging_dim = m;
	}
	else if (which_major == "col-major"|| which_major == "colmajor") {
		leading_dim = m;						//col-major => leading_dim = #rows
		lagging_dim = n;	
	}
}

void random_denseMat(const auto lead_dim, const auto lag_dim, auto &mat_A){
	for (int i = 0, ii = 0; i != lag_dim; ++i) {
		for (int j = 0; j != lead_dim; ++j, ++ii) {
			auto tmpA = rand()%10;
			mat_A[ii] = tmpA;
		}
	}

}
void diagonalMatrix(const auto lead_dim, const auto lag_dim, auto &mat_A){
	for (int i = 0, ii=0; i != lag_dim; ++i) {
		for (int j = 0; j != lead_dim; ++j, ++ii) {
			if(i==j){
				auto tmpA = randNum();
				mat_A[ii] = tmpA;			//row-major
			}
			else
				mat_A[ii] = 0;
		}
	}
}

void transpose(const auto lead_dim, const auto lag_dim, const std::vector<auto> matrix, std::vector<auto> &transpose_matrix) {
	//this simply changes data layout	
	for (int i = 0, ii = 0; i != lag_dim; ++i) {
		for (int j = 0;  j != lead_dim; ++j, ++ii) {
			transpose_matrix[j*lead_dim + i] = matrix[ii];
		}
	}
}

void isect (const std::vector<auto> idx_A, const std::vector<auto> idx_B, std::vector<auto> &isect_vec) {			//intersection of A.JC and BT.JC; set of indices that contribute non-trivially to outer product
	for (int i = 0; i!= idx_A.size(); ++i){
		for (int j = 0; j!= idx_B.size(); ++j){
			if(idx_A[i] == idx_B[j])							//get ONLY elements common only once
				isect_vec.push_back(idx_A[i]);
		}
	}	
}

void convert_triples_to_csc(const int rows, const int cols, const auto triples_A, auto &val, auto &indices, auto &jc_csc) {
	std::vector <int> row_idx, col_idx;
	for (my_tuple::const_iterator i = triples_A.begin(); i != triples_A.end(); ++i) {
		row_idx.push_back(std::get<0>(*i));
		col_idx.push_back(std::get<1>(*i));
		if (which_major == "col-major"|| which_major == "colmajor"){
			indices.push_back(std::get<0>(*i));
		}	
		else if (which_major == "row-major" || which_major == "rowmajor"){
			indices.push_back(std::get<1>(*i));
		}
		val.push_back(std::get<2>(*i));
	}

	int nnz = val.size();
	int cnt = 0;
	for (int i = 0; i != cols; ++i){				//pythonic range-based for loops
		for (int j = 0; j != nnz; ++j) {
			if (j==0) {
				jc_csc.push_back(cnt);
			}
			if (col_idx[j] == i) {
				++cnt;
			}
		}
	}
	jc_csc.push_back(val.size());
}

void convert_triples_to_dcsc(const int rows, const int cols, const auto triples_A, auto &val, auto &indices, auto &cp_dcsc, auto &jc_dcsc, auto &aux, auto &nnz, auto &nzc, auto &upper_bound_cf) {
	std::vector <int> row_idx, col_idx, jc_csc;
	for (my_tuple::const_iterator i = triples_A.begin(); i != triples_A.end(); ++i) {
		row_idx.push_back(std::get<0>(*i));
		col_idx.push_back(std::get<1>(*i));
		if (which_major == "col-major"|| which_major == "colmajor"){
			int r = std::get<0>(*i);
			int c = std::get<1>(*i);
			indices.push_back(r);
			if (std::find(jc_dcsc.begin(), jc_dcsc.end(), c) == jc_dcsc.end()) {	//if elem not found
				jc_dcsc.push_back(c);
			}
		}	
		else if (which_major == "row-major" || which_major == "rowmajor"){
			indices.push_back(std::get<1>(*i));
			jc_dcsc.push_back(std::get<0>(*i));
		}
		val.push_back(std::get<2>(*i));
	}

	nnz = val.size();
	
	int cnt = 0;
	//chunk size cf = (n+1)/nzc :: nzc = number of nonzero cols
	nzc = jc_dcsc.size();
	
	double cf = (double) (cols+1)/nzc;
	//std::cout << "cf " << cf << std::endl;
	upper_bound_cf = ceil(cf);
	
	
	for (int i = 0; i != cols; ++i){
		for (int j = 0; j != nnz; ++j) {
			if (j == 0){
				jc_csc.push_back(cnt);
			}
			if (j == 0 && std::find(cp_dcsc.begin(), cp_dcsc.end(), cnt) == cp_dcsc.end()) {
				cp_dcsc.push_back(cnt);
			}
			if (col_idx[j] == i) {
				++cnt;
			}
		}
	}
	jc_csc.push_back(nnz);			//size of jc_csc = cols + 1
	//std::cout << "csc format jc" << std::endl;
	//printVec(jc_csc);
	std::vector <int> d, cp;
	int cnt_aux = 0, cnt_cf = 0;
	bool flag_cf = true;
	for (int i = 0; i != cols+1; ++i){
		//std::cout << "cnt_cf " << cnt_cf << std::endl;
		//std::cout << "cnt_aux " << cnt_aux << std::endl;
		int tmp = jc_csc[i+1] - jc_csc[i];
		d.push_back(tmp);
		if (tmp != 0) {
			cp.push_back(jc_csc[i]);
			if (flag_cf == true) {
				aux.push_back(cnt_aux);
				flag_cf = false;
			}
			++cnt_aux;
		}

		++cnt_cf;
		if (cnt_cf % upper_bound_cf == 0) {
			flag_cf = true;
			cnt_cf = 0;
		}
		
	}
	/*
	std::cout << "diff arr" << std::endl;
	printVec(d);
	std::cout << "last element of d " << d[cols] << std::endl;
	std::cout << "cp arr" << std::endl;
	printVec(cp);
	*/

	//pushback total number of cols to aux
	aux.push_back(nzc);
	//std::cout << "aux" << std::endl;
	//printVec(aux);
}

void get_sorted_indices(const auto lead_dim, const auto lag_dim, const auto sparse_matrix, auto &val, auto &indices) {
	std::vector <int> idx_ptr, cp_arr, csc_jc, jc_new;
	int cnt = 0;
	bool flag_csc_jc = false, flag_cp_arr = false;
	for(int i = 0, ii=0; i != lag_dim; ++i){
		for(int j = 0; j != lead_dim; ++j, ++ii){
			if (j==0) {
				//flag_csc_jc = true;
				flag_cp_arr = true;
			}
			idx_ptr.push_back(cnt);
			if(sparse_matrix[ii] != 0){
				val.push_back(sparse_matrix[ii]);
				indices.push_back(j);				//indices contain col_ind if rowmajor, row_ind if col-major	
				jc_new.push_back(i);				//jc contains cols/rows that contain atleast one nnz element
				if (flag_cp_arr == true) {
					cp_arr.push_back(cnt);
					flag_cp_arr = false;
				}
				cnt++;
			}
		} 
	}
	int nnz = val.size();
	std::cout << "nnz " << nnz << std::endl;
	idx_ptr.push_back(nnz);
	cp_arr.push_back(nnz);
	int cf;
	int rows, cols;
	get_dim_from_major(lead_dim, lag_dim, rows, cols);
	cf = (cols + 1)/nnz;
	std::cout << "cf " << cf << std::endl;
	std::cout << "cp_arr" << std::endl;
	printVec(cp_arr);
	std::cout << "old csc jc array" << std::endl;
	printVec(csc_jc);
	//std::cout << "row ptr in csr storage" << std::endl;
	//printVec(row_ptr);

}

void access_elem_in_matrix(const auto i, const auto j, const auto nnz, const auto nzc, const auto cf, const auto &val, const auto &ir, const auto &jc, const auto &cp, const auto &aux) {
	int idx = floor(j/cf);
	int s = aux[idx];
	int e = aux[idx+1] - 1;
	std::cout << "start " << s << " end " << e << std::endl;
	auto start = std::begin(jc) + s;
	auto end = std::begin(jc) + e;
	int pos;
	for (auto m = start; m <= end; ++m) {
		if (j == *m) {
			std::cout << "found element " << j << " in " << "jc[" << *m << "]" << std::endl;
			pos = *m;
		}
	}
	int sc = cp[pos];
	int ec = cp[pos+1] - 1;
	std::cout << "startc " << sc << " endc " << ec << std::endl;
	auto startc = std::begin(ir) + sc;
	auto endc = std::begin(ir) + ec;
	int posc;
	for (auto n = startc; n <= endc; ++n) {
		if (i == *n) {
			std::cout << "found element " << i << " in " << "ir[" << *n << "]" << std::endl;
			posc = *n;
		}
	}
	std::cout << "element found! Value is " << val[posc] << std::endl;
	

	
}

int main (int argc, char *argv[]) {
	//int m, n;
	//m = n = 4;
	int m = atoi(argv[2]);
	int n = atoi(argv[3]);
	which_major = argv[1];
	int lead_dim, lag_dim;					//for both matrices but two diff for multiplication
	check_major(m, n, lead_dim, lag_dim);
	//std::cout << "row/col major? " << which_major << std::endl;
	//std::cout << "leading_dim " << lead_dim << " lag_dim " << lag_dim << std::endl;
	//std::vector<double> sparse = {1, 2, 0, 0, 0, 0, 0, 0, 2, 3, 4, 0, 3, 0, 5, 16};
	std::vector<double> sparse = {1, 2, 0, 0, 0, 0, 4, 0, 3, 0.5, 0, 2};
	std::vector<double> A = sparse;
	//printMatrix(lead_dim, lag_dim, "matrix A", A);
	
	std::vector <double> val_A;
	std::vector <int> idx;
	//get_sorted_indices(lead_dim, lag_dim, A, val_A, idx);				//get col indices of A									//matrix stored in row major
	
	//given triples
	my_tuple triples_A;
	triples_A.push_back(std::make_tuple(5,0,0.1));
	triples_A.push_back(std::make_tuple(7,0,0.2));
	triples_A.push_back(std::make_tuple(3,6,0.3));
	triples_A.push_back(std::make_tuple(1,7,0.4));

	//functionality to sort triples before/after func
	//right now has to be sorted by cols
	my_tuple eg_A;
	eg_A.push_back(std::make_tuple(0,0,0.2));
	eg_A.push_back(std::make_tuple(0,1,0.3));
	eg_A.push_back(std::make_tuple(1,1,0.4));
	eg_A.push_back(std::make_tuple(8,5,0.1));

	my_tuple whiteboard;
	whiteboard.push_back(std::make_tuple(2,0,1));
	whiteboard.push_back(std::make_tuple(2,2,2));
	whiteboard.push_back(std::make_tuple(0,3,3));
	whiteboard.push_back(std::make_tuple(2,4,4));

	std::vector <int> col_ptrs, indices;
	std::vector <double> num;
	convert_triples_to_csc(9, 9, triples_A, num, indices, col_ptrs);
	/*std::cout << "num" << std::endl;
	printVec(num);
	std::cout << "row indices" << std::endl;
	printVec(indices);
	std::cout << "jc_csc_ptrs" << std::endl;
	printVec(col_ptrs);
	*/
	std::vector <int> ir, cp_dcsc, jc_dcsc, aux;
	std::vector <double> num_dcsc;
	int nnz, nzc, cf;
	convert_triples_to_dcsc(9, 9, eg_A, num_dcsc, ir, cp_dcsc, jc_dcsc, aux, nnz, nzc, cf);

	std::cout << "nnz " << nnz << std::endl;
	std::cout << "nzc " << nzc << std::endl;
	std::cout << "upper cf " << cf << std::endl;
	std::cout << "num" << std::endl;
	printVec(num_dcsc);
	std::cout << "ir" << std::endl;
	printVec(ir);
	std::cout << "jc" << std::endl;
	printVec(jc_dcsc);
	std::cout << "cp" << std::endl;
	printVec(cp_dcsc);
	std::cout << "aux" << std::endl;
	printVec(aux);

	std::cout << "search for element A(1,1)" << std::endl;
	access_elem_in_matrix(1, 1, nnz, nzc, cf, num_dcsc, ir, jc_dcsc, cp_dcsc, aux);
	return 0;
}